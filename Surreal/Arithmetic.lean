import Mathlib.Tactic.Linarith
import Mathlib.Data.List.MinMax
import Mathlib.Order.Basic
import Surreal.game
import Surreal.surreal

-- We wish to define addition on surreal numbers. But first we need
-- to define addition on games.
open Game
def Game.add : Game → Game → Game
  | x, y =>
    match _hx : x, _hy : y with
    | mk XL XR, mk YL YR =>
      let L := (XL.map (fun xl => xl.add y)) ++ (YL.map (fun yl => x.add yl))
      let R := (XR.map (fun xr => xr.add y)) ++ (YR.map (fun yr => x.add yr))
      mk L R
  termination_by x y => x.birthday + y.birthday
    decreasing_by
    · -- Case 1: xl.add y
      rename_i h
      have hxl_lt : xl.birthday < (mk XL XR).birthday :=
        birthday_lt_left (mk XL XR) xl (by simpa [Game.left] using h)
      have hmeasure : xl.birthday + y.birthday < (mk XL XR).birthday + y.birthday :=
            add_lt_add_right hxl_lt y.birthday
      simpa [_hy] using hmeasure

    · -- Case 2: x.add yl
      rename_i h
      have hyl_lt : yl.birthday < (mk YL YR).birthday :=
        birthday_lt_left (mk YL YR) yl  (by simpa [Game.left] using h)
      have hmeasure : x.birthday + yl.birthday
            < x.birthday + (mk YL YR).birthday := add_lt_add_left hyl_lt x.birthday
      simpa [_hx] using hmeasure

    · -- Case 3: xr.add y
      rename_i h
      have hxr_lt : xr.birthday < (mk XL XR).birthday :=
          birthday_lt_right (mk XL XR) xr (by simpa [Game.right] using h)
      have hmeasure : xr.birthday + y.birthday < (mk XL XR).birthday + y.birthday :=
        add_lt_add_right hxr_lt y.birthday
      simpa [_hy] using hmeasure

    · -- Case 4: x.add yr
      rename_i h
      have hyr_lt : yr.birthday < (mk YL YR).birthday :=
        birthday_lt_right (mk YL YR) yr (by simpa [Game.right] using h)
      have hmeasure : x.birthday + yr.birthday < x.birthday + (mk YL YR).birthday :=
        add_lt_add_left hyr_lt x.birthday
      simpa [_hx] using hmeasure

lemma map_id_iff {α : Type} (f : α → α) (l : List α) :
  l.map f = l ↔ ∀ x ∈ l, f x = x := by
  induction l with
  | nil => simp
  | cons h t ih => simp [ih]



theorem Game.add_zero (a : Game) : Game.add a zero = a := by
  -- 1. Use the well-ordered induction method to conduct a
  -- recursive proof based on the birthday of the game.
  apply wf_R.induction a
  intro x IH --
  -- 2. unfold R and zero
  unfold R at IH
  rw [zero] at IH
  -- 3. unfold x and match x
  unfold add
  match hx : x with
  | mk XL XR =>
    -- 4. ∀ xl ∈ XL, xl + 0 = xl
    have h_ind_L : ∀ xl ∈ XL, xl.add (mk [] []) = xl := by
      intro xl hxl
      apply IH
      have id : x.left = XL := by rw [hx]; rfl
      rw [← id] at hxl
      rw [← hx]
      exact birthday_lt_left x xl hxl
    -- 5. ∀ xr ∈ XR, xr + 0 = xr
    have h_ind_R : ∀ xr ∈ XR, xr.add (mk [] []) = xr := by
      intro xr hxr
      apply IH
      have id : x.right = XR := by rw [hx]; rfl
      rw [← id] at hxr
      rw [← hx]
      exact birthday_lt_right x xr hxr
    -- 6. List operations generated by simplified addition
    simp [zero]
    -- 7. equality
    constructor
    · rw [map_id_iff]
      apply h_ind_L
    · rw [map_id_iff]
      apply h_ind_R


theorem Game.zero_add (a : Game) : Game.add zero a = a := by
  apply wf_R.induction a
  intro x IH --
  unfold R at IH
  rw [zero] at IH
  unfold add
  match hx : x with
  | mk XL XR =>
    -- 4. ∀ xl ∈ XL, 0 + xl = xl
    have h_ind_L : ∀ xl ∈ XL, (mk [] []).add xl = xl := by
      intro xl hxl
      apply IH
      have id : x.left = XL := by rw [hx]; rfl
      rw [← id] at hxl
      rw [← hx]
      exact birthday_lt_left x xl hxl
    -- 5. ∀ xr ∈ XR, 0 + xr = xr
    have h_ind_R : ∀ xr ∈ XR,  (mk [] []).add xr = xr := by
      intro xr hxr
      apply IH
      have id : x.right = XR := by rw [hx]; rfl
      rw [← id] at hxr
      rw [← hx]
      exact birthday_lt_right x xr hxr
    simp [zero]
    constructor
    · rw [map_id_iff]
      apply h_ind_L
    · rw [map_id_iff]
      apply h_ind_R


-- These two lemmas must be proved hand-in-hand by induction on
-- birthday(a) + birthday(b) + birthday(a') + birthday(b').
-- Perhaps need to group them into one theorem using `and`.
lemma Game.add_le_add (a b a' b' : Game) :
  a.le a' → b.le b' → (a.add b).le (a'.add b') := by
  sorry

lemma Game.Addlem2  (a b a' b' : Game) :
  (a'.add b').le (a.add b) → (b.le b') → (a'.le a) := by
  sorry


theorem Game.add_equal (a b a' b' : Game) :
  (a.eq a') ∧ (b.eq b') → (a.add b).eq (a'.add b') := by
  intro ⟨h1, h2⟩
  unfold eq at h1 h2
  unfold eq
  constructor
  · exact Game.add_le_add a b a' b' h1.1 h2.1
  · exact Game.add_le_add a' b' a b h1.2 h2.2

theorem Game.add_lt (a b a' b' : Game) :
  (a.lt a') ∧ (b.le b') → (a.add b).lt (a'.add b') := by
  intro ⟨h1, h2⟩
  have LE: (a.add b).le (a'.add b') := by
   exact Game.add_le_add a b a' b' h1.1 h2
  unfold lt
  constructor
  · exact Game.add_le_add a b a' b' h1.1 h2
  · intro h_contra
    have h_bad : a'.le a := Game.Addlem2 a b a' b' h_contra h2
    exact h1.2 h_bad

theorem Game.add_isSurreal (a b : Surreal) :
  IsSurreal (a.val.add b.val) := by
  sorry


theorem Game.add_comm (a b : Game) : eq (a.add b) (b.add a) := by
  induction a using wf_R.induction generalizing b
  case h x IH_x =>
    induction b using wf_R.induction
    case h y IH_y =>
      cases x with | mk XL XR =>
      cases y with | mk YL YR =>

      apply Game.eq_of_equiv_options

      -- 1. Left options of (x + y) ⊆ Left options of (y + x)
      · intro l hl
        rw [Game.add] at hl
        simp only [left, List.mem_append, List.mem_map] at hl
        rcases hl with h_left_x | h_left_y
        · -- l = xl + y. Match with y + xl
          rcases h_left_x with ⟨xl, hxl, rfl⟩
          exists (mk YL YR).add xl
          constructor
          · rw [Game.add]; simp only [left, List.mem_append, List.mem_map]
            right -- Select XL branch
            use xl
          · exact IH_x xl (birthday_lt_left _ _ hxl) (mk YL YR)
        · -- l = x + yl. Match with yl + x
          rcases h_left_y with ⟨yl, hyl, rfl⟩
          exists yl.add (mk XL XR)
          constructor
          · rw [Game.add]; simp only [left, List.mem_append, List.mem_map]
            left -- Select YL branch
            use yl
          · exact IH_y yl (birthday_lt_left _ _ hyl)

      -- 2. Left options of (y + x) ⊆ Left options of (x + y)
      · intro l hl
        rw [Game.add] at hl
        simp only [left, List.mem_append, List.mem_map] at hl
        rcases hl with h_left_y | h_left_x
        · -- l = yl + x. Match with x + yl
          rcases h_left_y with ⟨yl, hyl, rfl⟩
          exists (mk XL XR).add yl
          constructor
          · rw [Game.add]; simp only [left, List.mem_append, List.mem_map]
            right -- Select YL branch
            use yl
          · let h := IH_y yl (birthday_lt_left _ _ hyl)
            exact ⟨h.2, h.1⟩
        · -- l = y + xl. Match with xl + y
          rcases h_left_x with ⟨xl, hxl, rfl⟩
          exists xl.add (mk YL YR)
          constructor
          · rw [Game.add]; simp only [left, List.mem_append, List.mem_map]
            left -- Select XL branch
            use xl
          · let h := IH_x xl (birthday_lt_left _ _ hxl) (mk YL YR)
            exact ⟨h.2, h.1⟩

      -- 3. Right options of (x + y) ⊆ Right options of (y + x)
      · intro r hr
        rw [Game.add] at hr
        simp only [right, List.mem_append, List.mem_map] at hr
        rcases hr with h_right_x | h_right_y
        · -- r = xr + y. Match with y + xr
          rcases h_right_x with ⟨xr, hxr, rfl⟩
          exists (mk YL YR).add xr
          constructor
          · rw [Game.add]; simp only [right, List.mem_append, List.mem_map]
            right -- Select XR branch
            use xr
          · exact IH_x xr (birthday_lt_right _ _ hxr) (mk YL YR)
        · -- r = x + yr. Match with yr + x
          rcases h_right_y with ⟨yr, hyr, rfl⟩
          exists yr.add (mk XL XR)
          constructor
          · rw [Game.add]; simp only [right, List.mem_append, List.mem_map]
            left -- Select YR branch
            use yr
          · exact IH_y yr (birthday_lt_right _ _ hyr)

      -- 4. Right options of (y + x) ⊆ Right options of (x + y)
      · intro r hr
        rw [Game.add] at hr
        simp only [right, List.mem_append, List.mem_map] at hr
        rcases hr with h_right_y | h_right_x
        · -- r = yr + x. Match with x + yr
          rcases h_right_y with ⟨yr, hyr, rfl⟩
          exists (mk XL XR).add yr
          constructor
          · rw [Game.add]; simp only [right, List.mem_append, List.mem_map]
            right -- Select YR branch
            use yr
          · let h := IH_y yr (birthday_lt_right _ _ hyr)
            exact ⟨h.2, h.1⟩
        · -- r = y + xr. Match with xr + y
          rcases h_right_x with ⟨xr, hxr, rfl⟩
          exists xr.add (mk YL YR)
          constructor
          · rw [Game.add]; simp only [right, List.mem_append, List.mem_map]
            left -- Select XR branch
            use xr
          · let h := IH_x xr (birthday_lt_right _ _ hxr) (mk YL YR)
            exact ⟨h.2, h.1⟩


lemma list_map_congr {α β : Type} (l : List α) (f g : α → β) (h : ∀ x ∈ l, f x = g x) :
  l.map f = l.map g := by
  induction l with
  | nil => rfl
  | cons x xs ih =>
    simp
    constructor
    · apply h; simp
    · intro y hy; apply h; simp [hy]

theorem Game.add_assoc (a b c : Game) : (a.add b).add c = a.add (b.add c) := by
  induction a using wf_R.induction generalizing b c
  case h x IH_x =>
    induction b using wf_R.induction generalizing c
    case h y IH_y =>
      induction c using wf_R.induction
      case h z IH_z =>
        cases x with | mk XL XR =>
        cases y with | mk YL YR =>
        cases z with | mk ZL ZR =>
        simp only [add, List.map_append, List.map_map, List.append_assoc]
        congr 1
        · congr 1
          -- Part A: XL terms. (xl + y) + z = xl + (y + z)
          · apply list_map_congr; intro xl hxl
            dsimp
            -- Apply IH: xl.add (y + z)
            rw [IH_x xl (birthday_lt_left _ _ hxl) (mk YL YR) (mk ZL ZR)]
            congr 1; rw [Game.add]

          · congr 1
            -- Part B: YL terms. (x + yl) + z = x + (yl + z)
            · apply list_map_congr; intro yl hyl
              dsimp
              -- Apply IH: x.add (yl + z)
              rw [IH_y yl (birthday_lt_left _ _ hyl) (mk ZL ZR)]

            -- Part C: ZL terms. (x + y) + zl = x + (y + zl)
            · apply list_map_congr; intro zl hzl
              dsimp
              -- Apply IH: (x + y).add zl
              rw [← IH_z zl (birthday_lt_left _ _ hzl)]
              conv_rhs => enter [1]; rw [Game.add]

        -- 2. Right Options
        · congr 1
          -- Part A: XR terms. (xr + y) + z = xr + (y + z)
          · apply list_map_congr; intro xr hxr
            dsimp
            rw [IH_x xr (birthday_lt_right _ _ hxr) (mk YL YR) (mk ZL ZR)]
            congr 1; rw [Game.add]

          · congr 1
            -- Part B: YR terms. (x + yr) + z = x + (yr + z)
            · apply list_map_congr; intro yr hyr
              dsimp
              rw [IH_y yr (birthday_lt_right _ _ hyr) (mk ZL ZR)]

            -- Part C: ZR terms. (x + y) + zr = x + (y + zr)
            · apply list_map_congr; intro zr hzr
              dsimp
              rw [← IH_z zr (birthday_lt_right _ _ hzr)]
              conv_rhs => enter [1]; rw [Game.add]


set_option linter.unusedVariables false
def Game.neg : Game → Game
  | g =>
    let L := g.right.attach.map (fun ⟨r, hr⟩ => Game.neg r)
    let R := g.left.attach.map (fun ⟨l, hl⟩ => Game.neg l)
    Game.mk L R
  termination_by g => g.birthday
  decreasing_by
    · exact birthday_lt_right g r hr
    · exact birthday_lt_left g l hl

theorem Game.neg_isSurreal (a : Surreal) :
  IsSurreal (Game.neg a) := by
  sorry

-- Seems like these two proofs require x to be a surreal number
theorem Game.add_neg (a : Game) :
  (a.add (Game.neg a)).eq zero := by
  sorry

theorem Game.neg_add (a : Game) :
  ((Game.neg a).add a).eq zero := by
  sorry





def Game.mult : Game → Game → Game
  | x, y =>
  match hx : x, hy : y with
  | mk XL XR, mk YL YR =>
  -- Use attach to get assumption
  -- Change 1: hxl -> _hxl (add underscore to suppress unused variable warning)
  let L :=
    List.zipWith (fun ⟨xl, _hxl⟩ ⟨yl, _hyl⟩ =>
      ((xl.mult y).add (x.mult yl)).add (xl.mult yl).neg) XL.attach YL.attach ++
    List.zipWith (fun ⟨xr, _hxr⟩ ⟨yr, _hyr⟩ =>
      ((xr.mult y).add (x.mult yr)).add (xr.mult yr).neg) XR.attach YR.attach
  let R :=
    List.zipWith (fun ⟨xl, _hxl⟩ ⟨yr, _hyr⟩ =>
      ((xl.mult y).add (x.mult yr)).add (xl.mult yr).neg) XL.attach YR.attach ++
    List.zipWith (fun ⟨xr, _hxr⟩ ⟨yl, _hyl⟩ =>
      ((xr.mult y).add (x.mult yl)).add (xr.mult yl).neg) XR.attach YL.attach
  Game.mk L R
  termination_by x y => x.birthday + y.birthday
  decreasing_by
  -- =================================================
  -- First zipwith
  -- =================================================
  -- 1. xl * y
  · have hxl_lt : xl.birthday < (mk XL XR).birthday :=
      -- Updated variable usage: hxl -> _hxl
      birthday_lt_left (mk XL XR) xl (by simpa [Game.left] using _hxl)
    have hmeasure : xl.birthday + y.birthday < (mk XL XR).birthday + y.birthday :=
      add_lt_add_right hxl_lt y.birthday
    simpa [hy] using hmeasure

  -- 2. x * yl
  · have hyl_lt : yl.birthday < (mk YL YR).birthday :=
      -- Updated variable usage: hyl -> _hyl
      birthday_lt_left (mk YL YR) yl (by simpa [Game.left] using _hyl)
    have hmeasure : x.birthday + yl.birthday < x.birthday + (mk YL YR).birthday :=
      add_lt_add_left hyl_lt x.birthday
    simpa [hx] using hmeasure

  -- 3. xl * yl
  · have hxl_lt : xl.birthday < (mk XL XR).birthday :=
      birthday_lt_left (mk XL XR) xl (by simpa [Game.left] using _hxl)
    have hyl_lt : yl.birthday < (mk YL YR).birthday :=
      birthday_lt_left (mk YL YR) yl (by simpa [Game.left] using _hyl)
    have hmeasure : xl.birthday + yl.birthday < (mk XL XR).birthday + (mk YL YR).birthday :=
      add_lt_add hxl_lt hyl_lt
    -- Change 2: Fixed indentation for assumption
    assumption

  -- =================================================
  -- Second zipwith
  -- =================================================

  -- 4. xr * y
  · have hxr_lt : xr.birthday < (mk XL XR).birthday :=
      birthday_lt_right (mk XL XR) xr (by simpa [Game.right] using _hxr)
    have hmeasure : xr.birthday + y.birthday < (mk XL XR).birthday + y.birthday :=
      add_lt_add_right hxr_lt y.birthday
    simpa [hy] using hmeasure

  -- 5. x * yr
  · have hyr_lt : yr.birthday < (mk YL YR).birthday :=
      birthday_lt_right (mk YL YR) yr (by simpa [Game.right] using _hyr)
    have hmeasure : x.birthday + yr.birthday < x.birthday + (mk YL YR).birthday :=
      add_lt_add_left hyr_lt x.birthday
    simpa [hx] using hmeasure

  -- 6. xr * yr
  · have hxr_lt : xr.birthday < (mk XL XR).birthday :=
      birthday_lt_right (mk XL XR) xr (by simpa [Game.right] using _hxr)
    have hyr_lt : yr.birthday < (mk YL YR).birthday :=
      birthday_lt_right (mk YL YR) yr (by simpa [Game.right] using _hyr)
    have hmeasure : xr.birthday + yr.birthday < (mk XL XR).birthday + (mk YL YR).birthday :=
      add_lt_add hxr_lt hyr_lt
    assumption

  -- =================================================
  -- Third zipwith
  -- =================================================

  -- 7. xl * y
  · have hxl_lt : xl.birthday < (mk XL XR).birthday :=
      birthday_lt_left (mk XL XR) xl (by simpa [Game.left] using _hxl)
    have hmeasure : xl.birthday + y.birthday < (mk XL XR).birthday + y.birthday :=
      add_lt_add_right hxl_lt y.birthday
    simpa [hy] using hmeasure

  -- 8. x * yr
  · have hyr_lt : yr.birthday < (mk YL YR).birthday :=
      birthday_lt_right (mk YL YR) yr (by simpa [Game.right] using _hyr)
    have hmeasure : x.birthday + yr.birthday < x.birthday + (mk YL YR).birthday :=
      add_lt_add_left hyr_lt x.birthday
    simpa [hx] using hmeasure

  -- 9. xl * yr
  · have hxl_lt : xl.birthday < (mk XL XR).birthday :=
      birthday_lt_left (mk XL XR) xl (by simpa [Game.left] using _hxl)
    have hyr_lt : yr.birthday < (mk YL YR).birthday :=
      birthday_lt_right (mk YL YR) yr (by simpa [Game.right] using _hyr)
    have hmeasure : xl.birthday + yr.birthday < (mk XL XR).birthday + (mk YL YR).birthday :=
      add_lt_add hxl_lt hyr_lt
    assumption

  -- =================================================
  -- Fourth Zipwith
  -- =================================================

  -- 10. xr * y
  · have hxr_lt : xr.birthday < (mk XL XR).birthday :=
      birthday_lt_right (mk XL XR) xr (by simpa [Game.right] using _hxr)
    have hmeasure : xr.birthday + y.birthday < (mk XL XR).birthday + y.birthday :=
      add_lt_add_right hxr_lt y.birthday
    simpa [hy] using hmeasure

  -- 11. x * yl
  · have hyl_lt : yl.birthday < (mk YL YR).birthday :=
      birthday_lt_left (mk YL YR) yl (by simpa [Game.left] using _hyl)
    have hmeasure : x.birthday + yl.birthday < x.birthday + (mk YL YR).birthday :=
      add_lt_add_left hyl_lt x.birthday
    simpa [hx] using hmeasure

  -- 12. xr * yl
  · have hxr_lt : xr.birthday < (mk XL XR).birthday :=
      birthday_lt_right (mk XL XR) xr (by simpa [Game.right] using _hxr)
    have hyl_lt : yl.birthday < (mk YL YR).birthday :=
      birthday_lt_left (mk YL YR) yl (by simpa [Game.left] using _hyl)
    have hmeasure : xr.birthday + yl.birthday < (mk XL XR).birthday + (mk YL YR).birthday :=
      add_lt_add hxr_lt hyl_lt
    assumption
