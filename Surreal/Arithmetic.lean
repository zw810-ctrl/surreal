import Mathlib.Tactic.Linarith
import Mathlib.Data.List.MinMax
import Mathlib.Order.Basic
import Surreal.game
import Surreal.surreal


-- We wish to define addition on surreal numbers. But first we need
-- to define addition on games.
open Game
def Game.add : Game → Game → Game
  | x, y =>
    match _hx : x, _hy : y with
    | mk XL XR, mk YL YR =>
      let L := (XL.map (fun xl => xl.add y)) ++ (YL.map (fun yl => x.add yl))
      let R := (XR.map (fun xr => xr.add y)) ++ (YR.map (fun yr => x.add yr))
      mk L R
  termination_by x y => x.birthday + y.birthday
    decreasing_by
    · -- Case 1: xl.add y
      rename_i h
      have hxl_lt :
          xl.birthday < (mk XL XR).birthday :=
        birthday_lt_left
          (mk XL XR)
          xl
          (by
            simpa [Game.left] using h)


      have hmeasure :
          xl.birthday + y.birthday
            < (mk XL XR).birthday + y.birthday :=
        add_lt_add_right hxl_lt y.birthday

      -- hy : y = mk YL YR
      simpa [_hy] using hmeasure


    · -- Case 2: x.add yl
      rename_i h
      have hyl_lt :
          yl.birthday < (mk YL YR).birthday :=
        birthday_lt_left
          (mk YL YR)
          yl
          (by
            simpa [Game.left] using h)


      have hmeasure :
          x.birthday + yl.birthday
            < x.birthday + (mk YL YR).birthday :=
        add_lt_add_left hyl_lt x.birthday


      simpa [_hx] using hmeasure


    · -- Case 3: xr.add y
      rename_i h
      have hxr_lt :
          xr.birthday < (mk XL XR).birthday :=
        birthday_lt_right
          (mk XL XR)
          xr
          (by
            simpa [Game.right] using h)


      have hmeasure :
          xr.birthday + y.birthday
            < (mk XL XR).birthday + y.birthday :=
        add_lt_add_right hxr_lt y.birthday


      simpa [_hy] using hmeasure


    · -- Case 4: x.add yr
      rename_i h
      have hyr_lt :
          yr.birthday < (mk YL YR).birthday :=
        birthday_lt_right
          (mk YL YR)
          yr
          (by
            simpa [Game.right] using h)


      have hmeasure :
          x.birthday + yr.birthday
            < x.birthday + (mk YL YR).birthday :=
        add_lt_add_left hyr_lt x.birthday


      simpa [_hx] using hmeasure

lemma map_id_iff {α : Type} (f : α → α) (l : List α) :
  l.map f = l ↔ ∀ x ∈ l, f x = x := by
  -- induction with list l
  induction l with
  | nil =>
    -- map f [] = [] Obvious
    simp
  | cons h t ih =>
    simp [ih]



theorem Game.add_zero (a : Game) : Game.add a zero = a := by
  -- 1. Use the well-ordered induction method to conduct a
  -- recursive proof based on the birthday of the game.

  apply wf_R.induction a
  intro x IH --

  -- 2. unfold R and zero
  unfold R at IH
  rw [zero] at IH

  -- 3. unfold x and match x
  unfold add
  match hx : x with
  | mk XL XR =>
    -- 4. ∀ xl ∈ XL, xl + 0 = xl
    have h_ind_L : ∀ xl ∈ XL, xl.add (mk [] []) = xl := by
      intro xl hxl
      apply IH
      have id : x.left = XL := by rw [hx]; rfl
      rw [← id] at hxl
      rw [← hx]
      exact birthday_lt_left x xl hxl

    -- 5. ∀ xr ∈ XR, xr + 0 = xr
    have h_ind_R : ∀ xr ∈ XR, xr.add (mk [] []) = xr := by
      intro xr hxr
      apply IH
      have id : x.right = XR := by rw [hx]; rfl
      rw [← id] at hxr
      rw [← hx]
      exact birthday_lt_right x xr hxr

    -- 6. List operations generated by simplified addition
    simp [zero]

    -- 7. equality
    constructor
    · rw [map_id_iff]
      apply h_ind_L
    · rw [map_id_iff]
      apply h_ind_R


theorem Game.zero_add (a : Game) : Game.add zero a = a := by
  -- 1. Use the well-ordered induction method to conduct a
  -- recursive proof based on the birthday of the game.

  apply wf_R.induction a
  intro x IH --

  -- 2. unfold R and zero
  unfold R at IH
  rw [zero] at IH

  -- 3. unfold x and match x
  unfold add
  match hx : x with
  | mk XL XR =>
    -- 4. ∀ xl ∈ XL, 0 + xl = xl
    have h_ind_L : ∀ xl ∈ XL, (mk [] []).add xl = xl := by
      intro xl hxl
      apply IH
      have id : x.left = XL := by rw [hx]; rfl
      rw [← id] at hxl
      rw [← hx]
      exact birthday_lt_left x xl hxl

    -- 5. ∀ xr ∈ XR, 0 + xr = xr
    have h_ind_R : ∀ xr ∈ XR,  (mk [] []).add xr = xr := by
      intro xr hxr
      apply IH
      have id : x.right = XR := by rw [hx]; rfl
      rw [← id] at hxr
      rw [← hx]
      exact birthday_lt_right x xr hxr

    -- 6. List operations generated by simplified addition
    simp [zero]

    -- 7. equality
    constructor
    · rw [map_id_iff]
      apply h_ind_L
    · rw [map_id_iff]
      apply h_ind_R


-- These two lemmas must be proved hand-in-hand by induction on
-- birthday(a) + birthday(b) + birthday(a') + birthday(b').
-- Perhaps need to group them into one theorem using `and`.
lemma Game.add_le_add (a b a' b' : Game) :
  a.le a' → b.le b' → (a.add b).le (a'.add b') := by
  sorry

lemma Game.Addlem2  (a b a' b' : Game) :
  (a'.add b').le (a.add b) → (b.le b') → (a'.le a) := by
  sorry


theorem Game.add_equal (a b a' b' : Game) :
  (a.eq a') ∧ (b.eq b') → (a.add b).eq (a'.add b') := by
  intro ⟨h1, h2⟩
  unfold eq at h1 h2
  unfold eq
  constructor
  exact Game.add_le_add a b a' b' h1.1 h2.1
  exact Game.add_le_add a' b' a b h1.2 h2.2

theorem Game.add_lt (a b a' b' : Game) :
  (a.lt a') ∧ (b.le b') → (a.add b).lt (a'.add b') := by
  intro ⟨h1, h2⟩
  have LE: (a.add b).le (a'.add b') := by
   exact Game.add_le_add a b a' b' h1.1 h2
  unfold lt
  constructor
  · exact Game.add_le_add a b a' b' h1.1 h2
  · intro h_contra
    have h_bad : a'.le a := Game.Addlem2 a b a' b' h_contra h2
    exact h1.2 h_bad



-- addition is commutative: check whether one needs a, b to be surreal
theorem Game.add_comm (a b : Game) :
  a.add b = b.add a := by
  sorry

theorem Game.add_assoc (a b c : Game) :
  (a.add b).add c = a.add (b.add c) := by
  sorry

def Game.neg : Game → Game
  | g =>
    let L := g.right.map (fun r => Game.neg r)
    let R := g.left.map (fun l => Game.neg l)
    Game.mk L R
  termination_by g => g.birthday
  decreasing_by
    · sorry
    · sorry

theorem Game.add_neg (a : Game) :
  (a.add (Game.neg a)).eq zero := by
  sorry

theorem Game.neg_add (a : Game) :
  ((Game.neg a).add a).eq zero := by
  sorry

theorem Game.neg_isSurreal (a : Surreal) :
  IsSurreal (Game.neg a) := by
  sorry

theorem Game.add_isSurreal (a b : Surreal) :
  IsSurreal (a.val.add b.val) := by
  sorry



def Game.mult : Game → Game → Game
  | x, y =>
  match hx : x, hy : y with
  | mk XL XR, mk YL YR =>
  -- Use attach to get assumption
  -- Change 1: hxl -> _hxl (add underscore to suppress unused variable warning)
  let L :=
    List.zipWith (fun ⟨xl, _hxl⟩ ⟨yl, _hyl⟩ =>
      ((xl.mult y).add (x.mult yl)).add (xl.mult yl).neg) XL.attach YL.attach ++
    List.zipWith (fun ⟨xr, _hxr⟩ ⟨yr, _hyr⟩ =>
      ((xr.mult y).add (x.mult yr)).add (xr.mult yr).neg) XR.attach YR.attach
  let R :=
    List.zipWith (fun ⟨xl, _hxl⟩ ⟨yr, _hyr⟩ =>
      ((xl.mult y).add (x.mult yr)).add (xl.mult yr).neg) XL.attach YR.attach ++
    List.zipWith (fun ⟨xr, _hxr⟩ ⟨yl, _hyl⟩ =>
      ((xr.mult y).add (x.mult yl)).add (xr.mult yl).neg) XR.attach YL.attach
  Game.mk L R
  termination_by x y => x.birthday + y.birthday
  decreasing_by
  -- =================================================
  -- First zipwith
  -- =================================================
  -- 1. xl * y
  · have hxl_lt : xl.birthday < (mk XL XR).birthday :=
      -- Updated variable usage: hxl -> _hxl
      birthday_lt_left (mk XL XR) xl (by simpa [Game.left] using _hxl)
    have hmeasure : xl.birthday + y.birthday < (mk XL XR).birthday + y.birthday :=
      add_lt_add_right hxl_lt y.birthday
    simpa [hy] using hmeasure

  -- 2. x * yl
  · have hyl_lt : yl.birthday < (mk YL YR).birthday :=
      -- Updated variable usage: hyl -> _hyl
      birthday_lt_left (mk YL YR) yl (by simpa [Game.left] using _hyl)
    have hmeasure : x.birthday + yl.birthday < x.birthday + (mk YL YR).birthday :=
      add_lt_add_left hyl_lt x.birthday
    simpa [hx] using hmeasure

  -- 3. xl * yl
  · have hxl_lt : xl.birthday < (mk XL XR).birthday :=
      birthday_lt_left (mk XL XR) xl (by simpa [Game.left] using _hxl)
    have hyl_lt : yl.birthday < (mk YL YR).birthday :=
      birthday_lt_left (mk YL YR) yl (by simpa [Game.left] using _hyl)
    have hmeasure : xl.birthday + yl.birthday < (mk XL XR).birthday + (mk YL YR).birthday :=
      add_lt_add hxl_lt hyl_lt
    -- Change 2: Fixed indentation for assumption
    assumption

  -- =================================================
  -- Second zipwith
  -- =================================================

  -- 4. xr * y
  · have hxr_lt : xr.birthday < (mk XL XR).birthday :=
      birthday_lt_right (mk XL XR) xr (by simpa [Game.right] using _hxr)
    have hmeasure : xr.birthday + y.birthday < (mk XL XR).birthday + y.birthday :=
      add_lt_add_right hxr_lt y.birthday
    simpa [hy] using hmeasure

  -- 5. x * yr
  · have hyr_lt : yr.birthday < (mk YL YR).birthday :=
      birthday_lt_right (mk YL YR) yr (by simpa [Game.right] using _hyr)
    have hmeasure : x.birthday + yr.birthday < x.birthday + (mk YL YR).birthday :=
      add_lt_add_left hyr_lt x.birthday
    simpa [hx] using hmeasure

  -- 6. xr * yr
  · have hxr_lt : xr.birthday < (mk XL XR).birthday :=
      birthday_lt_right (mk XL XR) xr (by simpa [Game.right] using _hxr)
    have hyr_lt : yr.birthday < (mk YL YR).birthday :=
      birthday_lt_right (mk YL YR) yr (by simpa [Game.right] using _hyr)
    have hmeasure : xr.birthday + yr.birthday < (mk XL XR).birthday + (mk YL YR).birthday :=
      add_lt_add hxr_lt hyr_lt
    assumption

  -- =================================================
  -- Third zipwith
  -- =================================================

  -- 7. xl * y
  · have hxl_lt : xl.birthday < (mk XL XR).birthday :=
      birthday_lt_left (mk XL XR) xl (by simpa [Game.left] using _hxl)
    have hmeasure : xl.birthday + y.birthday < (mk XL XR).birthday + y.birthday :=
      add_lt_add_right hxl_lt y.birthday
    simpa [hy] using hmeasure

  -- 8. x * yr
  · have hyr_lt : yr.birthday < (mk YL YR).birthday :=
      birthday_lt_right (mk YL YR) yr (by simpa [Game.right] using _hyr)
    have hmeasure : x.birthday + yr.birthday < x.birthday + (mk YL YR).birthday :=
      add_lt_add_left hyr_lt x.birthday
    simpa [hx] using hmeasure

  -- 9. xl * yr
  · have hxl_lt : xl.birthday < (mk XL XR).birthday :=
      birthday_lt_left (mk XL XR) xl (by simpa [Game.left] using _hxl)
    have hyr_lt : yr.birthday < (mk YL YR).birthday :=
      birthday_lt_right (mk YL YR) yr (by simpa [Game.right] using _hyr)
    have hmeasure : xl.birthday + yr.birthday < (mk XL XR).birthday + (mk YL YR).birthday :=
      add_lt_add hxl_lt hyr_lt
    assumption

  -- =================================================
  -- Fourth Zipwith
  -- =================================================

  -- 10. xr * y
  · have hxr_lt : xr.birthday < (mk XL XR).birthday :=
      birthday_lt_right (mk XL XR) xr (by simpa [Game.right] using _hxr)
    have hmeasure : xr.birthday + y.birthday < (mk XL XR).birthday + y.birthday :=
      add_lt_add_right hxr_lt y.birthday
    simpa [hy] using hmeasure

  -- 11. x * yl
  · have hyl_lt : yl.birthday < (mk YL YR).birthday :=
      birthday_lt_left (mk YL YR) yl (by simpa [Game.left] using _hyl)
    have hmeasure : x.birthday + yl.birthday < x.birthday + (mk YL YR).birthday :=
      add_lt_add_left hyl_lt x.birthday
    simpa [hx] using hmeasure

  -- 12. xr * yl
  · have hxr_lt : xr.birthday < (mk XL XR).birthday :=
      birthday_lt_right (mk XL XR) xr (by simpa [Game.right] using _hxr)
    have hyl_lt : yl.birthday < (mk YL YR).birthday :=
      birthday_lt_left (mk YL YR) yl (by simpa [Game.left] using _hyl)
    have hmeasure : xr.birthday + yl.birthday < (mk XL XR).birthday + (mk YL YR).birthday :=
      add_lt_add hxr_lt hyl_lt
    assumption
