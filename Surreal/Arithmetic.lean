import Mathlib.Tactic.Linarith
import Mathlib.Data.List.MinMax
import Mathlib.Order.Basic
import Surreal.game
import Surreal.surreal

-- We wish to define addition on surreal numbers. But first we need
-- to define addition on games.
open Game
def Game.add : Game → Game → Game
  | x, y =>
    match _hx : x, _hy : y with
    | mk XL XR, mk YL YR =>
      let L := (XL.map (fun xl => xl.add y)) ++ (YL.map (fun yl => x.add yl))
      let R := (XR.map (fun xr => xr.add y)) ++ (YR.map (fun yr => x.add yr))
      mk L R
  termination_by x y => x.birthday + y.birthday
    decreasing_by
    · -- Case 1: xl.add y
      rename_i h
      have hxl_lt : xl.birthday < (mk XL XR).birthday :=
        birthday_lt_left (mk XL XR) xl (by simpa [Game.left] using h)
      have hmeasure : xl.birthday + y.birthday < (mk XL XR).birthday + y.birthday :=
            add_lt_add_right hxl_lt y.birthday
      simpa [_hy] using hmeasure

    · -- Case 2: x.add yl
      rename_i h
      have hyl_lt : yl.birthday < (mk YL YR).birthday :=
        birthday_lt_left (mk YL YR) yl  (by simpa [Game.left] using h)
      have hmeasure : x.birthday + yl.birthday
            < x.birthday + (mk YL YR).birthday := add_lt_add_left hyl_lt x.birthday
      simpa [_hx] using hmeasure

    · -- Case 3: xr.add y
      rename_i h
      have hxr_lt : xr.birthday < (mk XL XR).birthday :=
          birthday_lt_right (mk XL XR) xr (by simpa [Game.right] using h)
      have hmeasure : xr.birthday + y.birthday < (mk XL XR).birthday + y.birthday :=
        add_lt_add_right hxr_lt y.birthday
      simpa [_hy] using hmeasure

    · -- Case 4: x.add yr
      rename_i h
      have hyr_lt : yr.birthday < (mk YL YR).birthday :=
        birthday_lt_right (mk YL YR) yr (by simpa [Game.right] using h)
      have hmeasure : x.birthday + yr.birthday < x.birthday + (mk YL YR).birthday :=
        add_lt_add_left hyr_lt x.birthday
      simpa [_hx] using hmeasure

lemma map_id_iff {α : Type} (f : α → α) (l : List α) :
  l.map f = l ↔ ∀ x ∈ l, f x = x := by
  induction l with
  | nil => simp
  | cons h t ih => simp [ih]


-------------------------------------------
----------------- a + 0 = a----------------
-------------------------------------------
theorem Game.add_zero (a : Game) : Game.add a zero = a := by
  -- 1. Use the well-ordered induction method to conduct a
  -- recursive proof based on the birthday of the game.
  apply wf_R.induction a
  intro x IH --
  -- 2. unfold R and zero
  unfold R at IH
  rw [zero] at IH
  -- 3. unfold x and match x
  unfold add
  match hx : x with
  | mk XL XR =>
    -- 4. ∀ xl ∈ XL, xl + 0 = xl
    have h_ind_L : ∀ xl ∈ XL, xl.add (mk [] []) = xl := by
      intro xl hxl
      apply IH
      have id : x.left = XL := by rw [hx]; rfl
      rw [← id] at hxl
      rw [← hx]
      exact birthday_lt_left x xl hxl
    -- 5. ∀ xr ∈ XR, xr + 0 = xr
    have h_ind_R : ∀ xr ∈ XR, xr.add (mk [] []) = xr := by
      intro xr hxr
      apply IH
      have id : x.right = XR := by rw [hx]; rfl
      rw [← id] at hxr
      rw [← hx]
      exact birthday_lt_right x xr hxr
    -- 6. List operations generated by simplified addition
    simp [zero]
    -- 7. equality
    constructor
    · rw [map_id_iff]
      apply h_ind_L
    · rw [map_id_iff]
      apply h_ind_R

-------------------------------------------
----------------- 0 + a = a----------------
-------------------------------------------
theorem Game.zero_add (a : Game) : Game.add zero a = a := by
  apply wf_R.induction a
  intro x IH --
  unfold R at IH
  rw [zero] at IH
  unfold add
  match hx : x with
  | mk XL XR =>
    -- 4. ∀ xl ∈ XL, 0 + xl = xl
    have h_ind_L : ∀ xl ∈ XL, (mk [] []).add xl = xl := by
      intro xl hxl
      apply IH
      have id : x.left = XL := by rw [hx]; rfl
      rw [← id] at hxl
      rw [← hx]
      exact birthday_lt_left x xl hxl
    -- 5. ∀ xr ∈ XR, 0 + xr = xr
    have h_ind_R : ∀ xr ∈ XR,  (mk [] []).add xr = xr := by
      intro xr hxr
      apply IH
      have id : x.right = XR := by rw [hx]; rfl
      rw [← id] at hxr
      rw [← hx]
      exact birthday_lt_right x xr hxr
    simp [zero]
    constructor
    · rw [map_id_iff]
      apply h_ind_L
    · rw [map_id_iff]
      apply h_ind_R


-- These two lemmas must be proved hand-in-hand by induction on
-- birthday(a) + birthday(b) + birthday(a') + birthday(b').
-- Perhaps need to group them into one theorem using `and`.
lemma Game.add_le_add (a b a' b' : Game) :
  a.le a' → b.le b' → (a.add b).le (a'.add b') := by
  sorry

lemma Game.Addlem2  (a b a' b' : Game) :
  (a'.add b').le (a.add b) → (b.le b') → (a'.le a) := by
  sorry

-------------------------------------------
--- Adding equal numbers give equal sum ---
-------------------------------------------
theorem Game.add_equal (a b a' b' : Game) : (a.eq a') ∧ (b.eq b') → (a.add b).eq (a'.add b') := by
  intro ⟨h1, h2⟩
  unfold eq at h1 h2
  unfold eq
  constructor
  · exact Game.add_le_add a b a' b' h1.1 h2.1
  · exact Game.add_le_add a' b' a b h1.2 h2.2

-------------------------------------------
-------- Addition is commutative ----------
-------------------------------------------
theorem Game.add_comm (a b : Game) : eq (a.add b) (b.add a) := by
  induction a using wf_R.induction generalizing b
  case h x IH_x =>
    induction b using wf_R.induction
    case h y IH_y =>
      cases x with | mk XL XR =>
      cases y with | mk YL YR =>

      apply Game.eq_of_equiv_options

      -- 1. Left options of (x + y) ⊆ Left options of (y + x)
      · intro l hl
        rw [Game.add] at hl
        simp only [left, List.mem_append, List.mem_map] at hl
        rcases hl with h_left_x | h_left_y
        · -- l = xl + y. Match with y + xl
          rcases h_left_x with ⟨xl, hxl, rfl⟩
          exists (mk YL YR).add xl
          constructor
          · rw [Game.add]; simp only [left, List.mem_append, List.mem_map]
            right -- Select XL branch
            use xl
          · exact IH_x xl (birthday_lt_left _ _ hxl) (mk YL YR)
        · -- l = x + yl. Match with yl + x
          rcases h_left_y with ⟨yl, hyl, rfl⟩
          exists yl.add (mk XL XR)
          constructor
          · rw [Game.add]; simp only [left, List.mem_append, List.mem_map]
            left -- Select YL branch
            use yl
          · exact IH_y yl (birthday_lt_left _ _ hyl)

      -- 2. Left options of (y + x) ⊆ Left options of (x + y)
      · intro l hl
        rw [Game.add] at hl
        simp only [left, List.mem_append, List.mem_map] at hl
        rcases hl with h_left_y | h_left_x
        · -- l = yl + x. Match with x + yl
          rcases h_left_y with ⟨yl, hyl, rfl⟩
          exists (mk XL XR).add yl
          constructor
          · rw [Game.add]; simp only [left, List.mem_append, List.mem_map]
            right -- Select YL branch
            use yl
          · let h := IH_y yl (birthday_lt_left _ _ hyl)
            exact ⟨h.2, h.1⟩
        · -- l = y + xl. Match with xl + y
          rcases h_left_x with ⟨xl, hxl, rfl⟩
          exists xl.add (mk YL YR)
          constructor
          · rw [Game.add]; simp only [left, List.mem_append, List.mem_map]
            left -- Select XL branch
            use xl
          · let h := IH_x xl (birthday_lt_left _ _ hxl) (mk YL YR)
            exact ⟨h.2, h.1⟩

      -- 3. Right options of (x + y) ⊆ Right options of (y + x)
      · intro r hr
        rw [Game.add] at hr
        simp only [right, List.mem_append, List.mem_map] at hr
        rcases hr with h_right_x | h_right_y
        · -- r = xr + y. Match with y + xr
          rcases h_right_x with ⟨xr, hxr, rfl⟩
          exists (mk YL YR).add xr
          constructor
          · rw [Game.add]; simp only [right, List.mem_append, List.mem_map]
            right -- Select XR branch
            use xr
          · exact IH_x xr (birthday_lt_right _ _ hxr) (mk YL YR)
        · -- r = x + yr. Match with yr + x
          rcases h_right_y with ⟨yr, hyr, rfl⟩
          exists yr.add (mk XL XR)
          constructor
          · rw [Game.add]; simp only [right, List.mem_append, List.mem_map]
            left -- Select YR branch
            use yr
          · exact IH_y yr (birthday_lt_right _ _ hyr)

      -- 4. Right options of (y + x) ⊆ Right options of (x + y)
      · intro r hr
        rw [Game.add] at hr
        simp only [right, List.mem_append, List.mem_map] at hr
        rcases hr with h_right_y | h_right_x
        · -- r = yr + x. Match with x + yr
          rcases h_right_y with ⟨yr, hyr, rfl⟩
          exists (mk XL XR).add yr
          constructor
          · rw [Game.add]; simp only [right, List.mem_append, List.mem_map]
            right -- Select YR branch
            use yr
          · let h := IH_y yr (birthday_lt_right _ _ hyr)
            exact ⟨h.2, h.1⟩
        · -- r = y + xr. Match with xr + y
          rcases h_right_x with ⟨xr, hxr, rfl⟩
          exists xr.add (mk YL YR)
          constructor
          · rw [Game.add]; simp only [right, List.mem_append, List.mem_map]
            left -- Select XR branch
            use xr
          · let h := IH_x xr (birthday_lt_right _ _ hxr) (mk YL YR)
            exact ⟨h.2, h.1⟩


lemma list_map_congr {α β : Type} (l : List α) (f g : α → β) (h : ∀ x ∈ l, f x = g x) :
  l.map f = l.map g := by
  induction l with
  | nil => rfl
  | cons x xs ih =>
    simp
    constructor
    · apply h; simp
    · intro y hy; apply h; simp [hy]


-------------------------------------------
-------- Addition is associative ----------
-------------------------------------------
theorem Game.add_assoc (a b c : Game) : (a.add b).add c = a.add (b.add c) := by
  induction a using wf_R.induction generalizing b c
  case h x IH_x =>
    induction b using wf_R.induction generalizing c
    case h y IH_y =>
      induction c using wf_R.induction
      case h z IH_z =>
        cases x with | mk XL XR =>
        cases y with | mk YL YR =>
        cases z with | mk ZL ZR =>
        simp only [add, List.map_append, List.map_map, List.append_assoc]
        congr 1
        · congr 1
          -- Part A: XL terms. (xl + y) + z = xl + (y + z)
          · apply list_map_congr; intro xl hxl
            dsimp
            -- Apply IH: xl.add (y + z)
            rw [IH_x xl (birthday_lt_left _ _ hxl) (mk YL YR) (mk ZL ZR)]
            congr 1; rw [Game.add]

          · congr 1
            -- Part B: YL terms. (x + yl) + z = x + (yl + z)
            · apply list_map_congr; intro yl hyl
              dsimp
              -- Apply IH: x.add (yl + z)
              rw [IH_y yl (birthday_lt_left _ _ hyl) (mk ZL ZR)]

            -- Part C: ZL terms. (x + y) + zl = x + (y + zl)
            · apply list_map_congr; intro zl hzl
              dsimp
              -- Apply IH: (x + y).add zl
              rw [← IH_z zl (birthday_lt_left _ _ hzl)]
              conv_rhs => enter [1]; rw [Game.add]

        -- 2. Right Options
        · congr 1
          -- Part A: XR terms. (xr + y) + z = xr + (y + z)
          · apply list_map_congr; intro xr hxr
            dsimp
            rw [IH_x xr (birthday_lt_right _ _ hxr) (mk YL YR) (mk ZL ZR)]
            congr 1; rw [Game.add]

          · congr 1
            -- Part B: YR terms. (x + yr) + z = x + (yr + z)
            · apply list_map_congr; intro yr hyr
              dsimp
              rw [IH_y yr (birthday_lt_right _ _ hyr) (mk ZL ZR)]

            -- Part C: ZR terms. (x + y) + zr = x + (y + zr)
            · apply list_map_congr; intro zr hzr
              dsimp
              rw [← IH_z zr (birthday_lt_right _ _ hzr)]
              conv_rhs => enter [1]; rw [Game.add]

lemma Game.add_lt (a b a' b' : Game) :
  (a.lt a') ∧ (b.le b') → (a.add b).lt (a'.add b') := by
  intro ⟨h1, h2⟩
  have LE: (a.add b).le (a'.add b') := by
   exact Game.add_le_add a b a' b' h1.1 h2
  unfold lt
  constructor
  · exact Game.add_le_add a b a' b' h1.1 h2
  · intro h_contra
    have h_bad : a'.le a := Game.Addlem2 a b a' b' h_contra h2
    exact h1.2 h_bad

lemma Game.add_lt2 (a b a' b' : Game) :
  (a.le a') ∧ (b.lt b') → (a.add b).lt (a'.add b') := by
    intro h
    have rev : (b.add a).lt (b'.add a') := Game.add_lt b a b' a' ⟨h.2, h.1⟩
    have comm_ab   : (a.add b).eq (b.add a) := Game.add_comm a b
    have comm_a'b' : (b'.add a').eq (a'.add b') := Game.add_comm b' a'
    unfold lt
    constructor
    · apply Game.le_trans _ (b.add a)
      constructor
      · exact comm_ab.1
      · apply Game.le_trans _ (b'.add a')
        constructor
        · exact rev.1
        · exact comm_a'b'.1
    · intro h_contra
      apply rev.2
      apply Game.le_trans _ (a'.add b')
      constructor
      · exact comm_a'b'.1
      · apply Game.le_trans _ (a.add b)
        constructor
        · exact h_contra
        · exact comm_ab.1

structure BiSurreal where
  a : Surreal
  b : Surreal

def U : BiSurreal → BiSurreal → Prop :=
  fun a b => birthday a.1 + birthday a.2  < birthday b.1 + birthday b.2
lemma wf_U : WellFounded U :=
  InvImage.wf (fun s : BiSurreal => birthday s.1 + birthday s.2) wellFounded_lt

lemma lt_imp_not_le {x y : Game} (h : lt x y) : ¬(le y x) := h.2

theorem add_isSurreal1 (x : BiSurreal) :
  IsSurreal (x.a.val.add x.b.val) := by
  apply wf_U.induction x
  intro x IH

  let a := x.a
  let b := x.b
  have sa := a.property
  have sb := b.property

  unfold Game.add
  split
  next AL AR BL BR ha hb =>
  unfold IsSurreal
  constructor
  · intro L hL R hR
    simp [left, right, List.mem_append] at hL hR
    apply lt_imp_not_le
    rcases hL with ⟨al, hal, rfl⟩ | ⟨bl, hbl, rfl⟩

-- =========================================================
-- Part 1: Left options less than Right options
-- =========================================================
    -- BRANCH 1: L = al + b
    · -- Now split on where the Right option R comes from: (a_R + b) or (a + b_R)
      rcases hR with ⟨ar, har, rfl⟩ | ⟨br, hbr, rfl⟩
      -- Case 1.1: al + b < ar + b
      · apply Game.add_lt
        constructor
        · -- al < ar (because a is Surreal)
          have h_al_lt_a : al.lt x.a.val := by
            have h_in : al ∈ x.a.val.left := by rw [ha]; simp [Game.left]; exact hal
            exact (xL_x_xR x.a).1 al h_in
          have h_a_lt_ar : x.a.val.lt ar := by
            have h_in : ar ∈ x.a.val.right := by rw [ha]; simp [Game.right]; exact har
            exact (xL_x_xR x.a).2 ar h_in
          exact Game.lt_trans al x.a ar ⟨h_al_lt_a, h_a_lt_ar⟩
        · -- b ≤ b
          exact Game.le_refl b

      -- Case 1.2: al + b < a + br
      · apply Game.add_lt
        constructor
        · -- al < a → al ≤ a
          have h_in : al ∈ x.a.val.left := by rw [ha]; simp [Game.left]; exact hal
          exact ((xL_x_xR x.a).1 al h_in)
        · -- b < br
          have h_in : br ∈ x.b.val.right := by rw [hb]; simp [Game.right]; exact hbr
          exact ((xL_x_xR x.b).2 br h_in).1

    -- BRANCH 2: L = a + bl
    · -- Now split on where the Right option R comes from
      rcases hR with ⟨ar, har, rfl⟩ | ⟨br, hbr, rfl⟩

      -- Case 2.1: a + bl < ar + b
      · apply Game.add_lt
        constructor
        · -- a < ar
          have h_in : ar ∈ x.a.val.right := by rw [ha]; simp [Game.right]; exact har
          exact (xL_x_xR x.a).2 ar h_in
        · -- bl < b → bl ≤ b
          have h_in : bl ∈ x.b.val.left := by rw [hb]; simp [Game.left]; exact hbl
          exact ((xL_x_xR x.b).1 bl h_in).1

      -- Case 2.2: a + bl < a + br
      · apply Game.add_lt2
        constructor
        · -- a ≤ a
          exact Game.le_refl a
        · -- bl < br (because b is Surreal)
          have h_bl_lt_b : bl.lt x.b.val := by
            have h_in : bl ∈ x.b.val.left := by rw [hb]; simp [Game.left]; exact hbl
            exact (xL_x_xR x.b).1 bl h_in
          have h_b_lt_br : x.b.val.lt br := by
            have h_in : br ∈ x.b.val.right := by rw [hb]; simp [Game.right]; exact hbr
            exact (xL_x_xR x.b).2 br h_in
          exact Game.lt_trans bl x.b br ⟨h_bl_lt_b, h_b_lt_br⟩

  -- =========================================================
  -- Part 2: Left and right options are surreal
  -- =========================================================
  · constructor
    -- 2.1 Left options are Surreal
    · intro L hL
      simp [left, List.mem_append] at hL
      rcases hL with ⟨al, hal, rfl⟩ | ⟨bl, hbl, rfl⟩
      · -- al + b is Surreal (by IH)
        unfold IsSurreal at sa
        rcases sa with ⟨_, sa_L, _⟩
        have s_al : IsSurreal al := by
          apply sa_L al
          rw [ha]; simp [Game.left]; exact hal
        apply IH {a := ⟨al, s_al⟩, b := b}
        simp [U]
        apply add_lt_add_right
        apply birthday_lt_left x.a.val al
        rw [ha]; simp [Game.left]; exact hal
      · -- a + bl is Surreal (by IH)
        unfold IsSurreal at sb
        rcases sb with ⟨_, sb_L, _⟩
        have s_bl : IsSurreal bl := by
          apply sb_L bl
          rw [hb]; simp [Game.left]; exact hbl
        apply IH {a := a, b := ⟨bl, s_bl⟩}
        simp [U]
        apply add_lt_add_left
        apply birthday_lt_left x.b.val bl
        rw [hb]; simp [Game.left]; exact hbl

    -- 2.2 Right options are Surreal
    · intro R hR
      simp [right, List.mem_append] at hR
      rcases hR with ⟨ar, har, rfl⟩ | ⟨br, hbr, rfl⟩
      · -- ar + b is Surreal (by IH)
        unfold IsSurreal at sa
        rcases sa with ⟨_, _, sa_R⟩
        have s_ar : IsSurreal ar := by
          apply sa_R ar
          rw [ha]; simp [Game.right]; exact har
        apply IH {a := ⟨ar, s_ar⟩, b := b}
        simp [U]
        apply add_lt_add_right
        apply birthday_lt_right x.a.val ar
        rw [ha]; simp [Game.right]; exact har
      · -- a + br is Surreal (by IH)
        unfold IsSurreal at sb
        rcases sb with ⟨_, _, sb_R⟩
        have s_br : IsSurreal br := by
          apply sb_R br
          rw [hb]; simp [Game.right]; exact hbr
        apply IH {a := a, b := ⟨br, s_br⟩}
        simp [U]
        apply add_lt_add_left
        apply birthday_lt_right x.b.val br
        rw [hb]; simp [Game.right]; exact hbr

-------------------------------------------
-------- Addition preserves surreal--------
-------------------------------------------
theorem Surreal.add_isSurreal (a b : Surreal) :
  IsSurreal (a.val.add b.val) := by
  let bi : BiSurreal := {a := a, b := b}
  apply add_isSurreal1 bi

def Surreal.add (a b : Surreal) :
  Surreal := ⟨(a.val).add b.val, Surreal.add_isSurreal a b⟩


------------------------------------------
--------- Definition of -a ---------------
------------------------------------------
set_option linter.unusedVariables false
def Game.neg : Game → Game
  | g =>
    let L := g.right.attach.map (fun ⟨r, hr⟩ => Game.neg r)
    let R := g.left.attach.map (fun ⟨l, hl⟩ => Game.neg l)
    Game.mk L R
  termination_by g => g.birthday
  decreasing_by
    · exact birthday_lt_right g r hr
    · exact birthday_lt_left g l hl



lemma neg_left_def (g : Game) : (Game.neg g).left =
  g.right.attach.map (fun ⟨r, _⟩ => Game.neg r) := by
  conv_lhs => rw [Game.neg]
  rfl

lemma neg_right_def (g : Game) : (Game.neg g).right =
  g.left.attach.map (fun ⟨l, _⟩ => Game.neg l) := by
  conv_lhs => rw [Game.neg]
  rfl

structure BiGame where
  a : Game
  b : Game

def B : BiGame → BiGame → Prop :=
  fun a b => birthday a.1 + birthday a.2 < birthday b.1 + birthday b.2
lemma wf_B : WellFounded B :=
  InvImage.wf (fun s : BiGame => birthday s.1 + birthday s.2) wellFounded_lt

theorem Game.neg_le_neg_iff (x : BiGame) : le x.a x.b ↔ le (neg x.b) (neg x.a) := by
  apply wf_B.induction x
  intro x IH
  let a := x.a
  let b := x.b
  constructor
  · intro h
    unfold le
    constructor
    -- Condition 1: ∀ L ∈ (-b).left, ¬(-a ≤ L)
    -- L = -bR where bR ∈ b.right
    · intro L hL
      rw [neg_left_def, List.mem_map] at hL
      rcases hL with ⟨⟨bR, hbR⟩, _, rfl⟩
      -- Assume -a ≤ -bR
      intro h_contra
      simp at h_contra
      -- IH implies: bR ≤ a ↔ -a ≤ -bR
      have IH_call := IH {a := bR, b := a}
      dsimp [B] at IH_call
      rw [Nat.add_comm a.birthday] at IH_call
      rw [add_lt_add_iff_right] at IH_call
      specialize IH_call (birthday_lt_right x.b bR hbR)
      -- So h_contra implies bR ≤ a
      rw [← IH_call] at h_contra
      -- But h (a ≤ b) implies ¬(bR ≤ a)
      unfold le at h
      exact h.2 bR hbR h_contra

    -- Condition 2: ∀ R ∈ (-a).right, ¬(R ≤ -b)
    -- R = -aL where aL ∈ a.left
    · intro R hR
      rw [neg_right_def, List.mem_map] at hR
      rcases hR with ⟨⟨aL, haL⟩, _, rfl⟩
      -- Assume -aL ≤ -b
      intro h_contra
      simp at h_contra
      -- Apply IH to {a := b, b := aL}
      have IH_call := IH {a := b, b := aL}
      dsimp [B] at IH_call
      rw [Nat.add_comm a.birthday] at IH_call
      rw [add_lt_add_iff_left] at IH_call
      specialize IH_call (birthday_lt_left x.a aL haL)
      -- So h_contra implies b ≤ aL
      rw [← IH_call] at h_contra
      -- But h (a ≤ b) implies ¬(b ≤ aL)
      unfold le at h
      exact h.1 aL haL h_contra

  -- === Direction 2: -b ≤ -a → a ≤ b ===
  · intro h
    unfold le
    unfold le at h
    constructor
    -- Condition 1: ∀ aL ∈ a.left, ¬(b ≤ aL)
    · intro aL haL b_le_aL -- Assume b ≤ aL

      -- IH: b ≤ aL ↔ -aL ≤ -b
      have IH_call := IH {a := b, b := aL}
      dsimp [B] at IH_call
      -- Metric: b + aL < a + b
      rw [Nat.add_comm a.birthday, add_lt_add_iff_left] at IH_call
      specialize IH_call (birthday_lt_left x.a aL haL)
      rw [IH_call] at b_le_aL

      -- h.2 says: ∀ R ∈ (-a).right, ¬(R ≤ -b)
      -- -aL is in (-a).right
      have h_not := h.2 (neg aL)
      rw [neg_right_def, List.mem_map] at h_not
      apply h_not _ b_le_aL
      simp
      use aL, haL

    -- Condition 2: ∀ bR ∈ b.right, ¬(bR ≤ a)
    · intro bR hbR bR_le_a -- Assume bR ≤ a
      -- IH: bR ≤ a ↔ -a ≤ -bR
      have IH_call := IH {a := bR, b := a}
      dsimp [B] at IH_call
      rw [Nat.add_comm a.birthday, add_lt_add_iff_right] at IH_call
      specialize IH_call (birthday_lt_right x.b bR hbR)
      rw [IH_call] at bR_le_a

      -- h.1 says: ∀ L ∈ (-b).left, ¬(-a ≤ L)
      -- -bR is in (-b).left
      have h_not := h.1 (neg bR)
      rw [neg_left_def, List.mem_map] at h_not
      apply h_not _ bR_le_a
      simp
      use bR, hbR

theorem Game.neg_le_neg (a b : Game) : le a b ↔ le (neg b) (neg a) := by
  let bi : BiGame := {a := a, b := b}
  apply Game.neg_le_neg_iff bi


theorem Game.neg_lt_neg (a b : Game) : lt a b ↔ lt (neg b) (neg a) := by
  -- Expand the definition of lt: a < b ↔ (a ≤ b ∧ ¬(b ≤ a))
  unfold lt
  rw [Game.neg_le_neg a b]
  rw [Game.neg_le_neg b a]


------------------------------------------
------ if a is surreal, so is -a ---------
------------------------------------------
theorem Surreal.neg_isSurreal (a : Surreal) :
  IsSurreal (Game.neg a.val) := by
  apply WellFounded.induction (InvImage.wf (fun s : Surreal => s.val.birthday) wellFounded_lt) a
  intro a IH
  let x := a.val
  have sx := a.property
  have neg_left : (Game.neg x).left = x.right.attach.map (fun ⟨r, _⟩ => Game.neg r) := by
    conv_lhs => rw [Game.neg]
    simp [Game.left]
  have neg_right : (Game.neg x).right = x.left.attach.map (fun ⟨l, _⟩ => Game.neg l) := by
    conv_lhs => rw [Game.neg]
    simp [Game.right]
  unfold IsSurreal at sx
  rcases sx with ⟨_, sx_L_surreal, sx_R_surreal⟩
  unfold IsSurreal
  constructor
  -- =========================================================
  -- Part 1: Order Condition (L < R for -x)
  -- =========================================================
  · intro L hL R hR
    rw [neg_left, List.mem_map] at hL
    rw [neg_right, List.mem_map] at hR
    rcases hL with ⟨⟨xr, hxr⟩, _, rfl⟩
    rcases hR with ⟨⟨xl, hxl⟩, _, rfl⟩

    apply lt_imp_not_le
    have h_xl_lt_xr : xl.lt xr := by
      let s_xl : Surreal := ⟨xl, sx_L_surreal xl hxl⟩
      let s_xr : Surreal := ⟨xr, sx_R_surreal xr hxr⟩
      have xl_lt_x := (xL_x_xR a).1 s_xl hxl
      have x_lt_xr := (xL_x_xR a).2 s_xr hxr
      exact Surreal.lt_trans s_xl a s_xr ⟨xl_lt_x, x_lt_xr⟩
    rw [Game.neg_lt_neg] at h_xl_lt_xr
    exact h_xl_lt_xr

  -- =========================================================
  -- Part 2: Recursive Condition
  -- =========================================================
  · constructor
    · intro L hL
      rw [neg_left, List.mem_map] at hL
      rcases hL with ⟨⟨xr, hxr⟩, _, rfl⟩
      apply IH ⟨xr, sx_R_surreal xr hxr⟩
      dsimp [InvImage]
      exact birthday_lt_right x xr hxr

    · intro R hR
      rw [neg_right, List.mem_map] at hR
      rcases hR with ⟨⟨xl, hxl⟩, _, rfl⟩
      apply IH ⟨xl, sx_L_surreal xl hxl⟩
      dsimp [InvImage]
      exact birthday_lt_left x xl hxl

-- The proof below require x to be a surreal number
-- Helper lemmas and axioms assumed from context
axiom Game.add_lt_le {a b a' b' : Game} : (lt a a') ∧ (le b b') → lt (add a b) (add a' b')
axiom Game.add_lt_comm {a b a' b' : Game} : (le a a') ∧ (lt b b') → lt (add a b) (add a' b')
axiom Game.neg_lt_neg_iff (a b : Game) : lt a b ↔ lt (neg b) (neg a)
lemma map_attach_eq_map {α β} (l : List α) (f : α → β) :
  l.attach.map (fun ⟨x, _⟩ => f x) = l.map f := by
  induction l <;> simp [*]


theorem neg_lt_neg_rev {x y : Game} (h : lt x y) : lt (Game.neg y) (Game.neg x) := by
  rw [← Game.neg_lt_neg_iff]
  exact h

theorem Game.lt_of_lt_of_le {x y z : Game} (hxy : lt x y) (hyz : le y z) : lt x z := by
  sorry

theorem Game.lt_of_le_of_lt {x y z : Game} (hxy : le x y) (hyz : lt y z) : lt x z := by
  sorry


theorem Surreal.add_neg (a : Surreal) : (a.val.add (Game.neg a.val)).eq zero := by
  apply WellFounded.induction (InvImage.wf (fun s : Surreal => s.val.birthday) wellFounded_lt) a
  intro a IH
  let x := a.val
  have sx := a.property

  unfold Game.eq
  constructor
  -- =========================================================
  -- Part 1: Prove (x + -x) ≤ 0
  -- =========================================================
  · unfold Game.le
    constructor
    -- 1. ∀ L ∈ (x + -x).left, L < 0
    · intro L hL
      change L ∈ (x.add (Game.neg x)).left at hL

      have h_cases : (∃ xl ∈ x.left, L = xl.add (Game.neg x)) ∨
                     (∃ xr ∈ x.right, L = x.add (Game.neg xr)) := by
        obtain ⟨XL, XR, hx_eq⟩ : ∃ L R, x = mk L R := ⟨x.left, x.right, by cases x; rfl⟩
        rw [hx_eq] at hL
        -- Controlled unfolding
        rw [Game.neg] at hL
        simp only [Game.left, Game.right] at hL
        rw [Game.add] at hL
        simp only [List.mem_append, List.mem_map, List.mem_attach] at hL

        rcases hL with ⟨xl, hxl, rfl⟩ | ⟨_, ⟨xr, hxr, rfl⟩, rfl⟩
        · left; use xl
          rw [hx_eq]; simp [Game.left, hxl]; congr 1; rw [Game.neg]
          simp only [Game.left, Game.right]
          congr 1
          all_goals { rw [map_attach_eq_map]}
        · right; use xr
          rw [hx_eq]; simp [Game.right]; exact xr.property

      rcases h_cases with ⟨xl, hxl, rfl⟩ | ⟨xr, hxr, rfl⟩

      -- Case 1: L = xl + (-x)
      · unfold IsSurreal at sx
        have xl_surreal : IsSurreal xl := sx.2.1 xl hxl
        have h_xl_lt_x : xl.lt x := (xL_x_xR a).1 xl hxl
        have h_neg_x_lt_neg_xl : (Game.neg x).lt (Game.neg xl) := neg_lt_neg_rev h_xl_lt_x

        have IH_xl := IH ⟨xl, xl_surreal⟩ (birthday_lt_left x xl hxl)
        have h_sum_zero : Game.le (xl.add (Game.neg xl)) zero := IH_xl.1

        -- Fix: Use And.intro explicitly
        have h_mono : Game.lt (xl.add (Game.neg x)) (xl.add (Game.neg xl)) :=
          Game.add_lt_comm (And.intro (Game.le_refl xl) h_neg_x_lt_neg_xl)

        have h_lt_zero : Game.lt (xl.add (Game.neg x)) zero :=
          Game.lt_of_lt_of_le h_mono h_sum_zero

        exact lt_imp_not_le h_lt_zero

      -- Case 2: L = x + (-xr)
      · unfold IsSurreal at sx
        have xr_surreal : IsSurreal xr := sx.2.2 xr hxr
        have h_x_lt_xr : x.lt xr := (xL_x_xR a).2 xr hxr

        have IH_xr := IH ⟨xr, xr_surreal⟩ (birthday_lt_right x xr hxr)
        have h_sum_zero : Game.le (xr.add (Game.neg xr)) zero := IH_xr.1

        -- Fix: Use And.intro explicitly
        have h_mono : Game.lt (x.add (Game.neg xr)) (xr.add (Game.neg xr)) :=
          Game.add_lt x (Game.neg xr) xr (Game.neg xr)
          (And.intro h_x_lt_xr (Game.le_refl (Game.neg xr)))

        have h_lt_zero : Game.lt (x.add (Game.neg xr)) zero :=
          Game.lt_of_lt_of_le h_mono h_sum_zero

        exact lt_imp_not_le h_lt_zero

    -- 2. ∀ R ∈ 0.right... (Empty)
    · intro R hR
      simp [zero, Game.right] at hR

  -- =========================================================
  -- Part 2: Prove 0 ≤ (x + -x)
  -- =========================================================
  · unfold Game.le
    constructor
    -- 1. ∀ L ∈ 0.left... (Empty)
    · intro L hL
      simp [zero, Game.left] at hL

    -- 2. ∀ R ∈ (x + -x).right, R > 0
    · intro R hR
      change R ∈ (x.add (Game.neg x)).right at hR

      have h_cases : (∃ xr ∈ x.right, R = xr.add (Game.neg x)) ∨
                     (∃ xl ∈ x.left, R = x.add (Game.neg xl)) := by
        obtain ⟨XL, XR, hx_eq⟩ : ∃ L R, x = mk L R := ⟨x.left, x.right, by cases x; rfl⟩
        rw [hx_eq] at hR
        rw [Game.neg] at hR
        simp only [Game.left, Game.right] at hR
        rw [Game.add] at hR
        simp only [List.mem_append, List.mem_map, List.mem_attach] at hR

        rcases hR with ⟨xr, hxr, rfl⟩ | ⟨_, ⟨xl, hxl, rfl⟩, rfl⟩
        · left; use xr
          rw [hx_eq]; simp [Game.right, hxr]; congr 1; rw [Game.neg]
          simp only [Game.left, Game.right]
          congr 1
          all_goals { rw [map_attach_eq_map]}
        · right; use xl
          rw [hx_eq]; simp [Game.left]; exact xl.property

      rcases h_cases with ⟨xr, hxr, rfl⟩ | ⟨xl, hxl, rfl⟩

      -- Case 1: R = xr + (-x)
      · unfold IsSurreal at sx
        have xr_surreal : IsSurreal xr := sx.2.2 xr hxr
        have h_x_lt_xr : x.lt xr := (xL_x_xR a).2 xr hxr
        have h_neg_xr_lt_neg_x : (Game.neg xr).lt (Game.neg x) := neg_lt_neg_rev h_x_lt_xr

        have IH_xr := IH ⟨xr, xr_surreal⟩ (birthday_lt_right x xr hxr)
        have h_zero_le_sum : Game.le zero (xr.add (Game.neg xr)) := IH_xr.2

        -- Fix: Use And.intro explicitly
        have h_mono : Game.lt (xr.add (Game.neg xr)) (xr.add (Game.neg x)) :=
           Game.add_lt_comm (And.intro (Game.le_refl xr) h_neg_xr_lt_neg_x)

        have h_zero_lt : Game.lt zero (xr.add (Game.neg x)) :=
           Game.lt_of_le_of_lt h_zero_le_sum h_mono

        exact lt_imp_not_le h_zero_lt

      -- Case 2: R = x + (-xl)
      · unfold IsSurreal at sx
        have xl_surreal : IsSurreal xl := sx.2.1 xl hxl
        have h_xl_lt_x : xl.lt x := (xL_x_xR a).1 xl hxl

        have IH_xl := IH ⟨xl, xl_surreal⟩ (birthday_lt_left x xl hxl)
        have h_zero_le_sum : Game.le zero (xl.add (Game.neg xl)) := IH_xl.2

        -- Fix: Use And.intro explicitly
        have h_mono : Game.lt (xl.add (Game.neg xl)) (x.add (Game.neg xl)) :=
           Game.add_lt xl (Game.neg xl) x (Game.neg xl)
           (And.intro h_xl_lt_x (Game.le_refl (Game.neg xl)))


        have h_zero_lt : Game.lt zero (x.add (Game.neg xl)) :=
           Game.lt_of_le_of_lt h_zero_le_sum h_mono

        exact lt_imp_not_le h_zero_lt

theorem Surreal.neg_add (a : Surreal) : ((Game.neg a).add a).eq zero := by
  apply Game.eq_trans _ ((a.val).add (Game.neg a))
  constructor
  · exact Game.add_comm (Game.neg a) a
  · exact Surreal.add_neg a




def Game.mult : Game → Game → Game
  | x, y =>
  match hx : x, hy : y with
  | mk XL XR, mk YL YR =>
  -- Use attach to get assumption
  -- Change 1: hxl -> _hxl (add underscore to suppress unused variable warning)
  let L :=
    List.zipWith (fun ⟨xl, _hxl⟩ ⟨yl, _hyl⟩ =>
      ((xl.mult y).add (x.mult yl)).add (xl.mult yl).neg) XL.attach YL.attach ++
    List.zipWith (fun ⟨xr, _hxr⟩ ⟨yr, _hyr⟩ =>
      ((xr.mult y).add (x.mult yr)).add (xr.mult yr).neg) XR.attach YR.attach
  let R :=
    List.zipWith (fun ⟨xl, _hxl⟩ ⟨yr, _hyr⟩ =>
      ((xl.mult y).add (x.mult yr)).add (xl.mult yr).neg) XL.attach YR.attach ++
    List.zipWith (fun ⟨xr, _hxr⟩ ⟨yl, _hyl⟩ =>
      ((xr.mult y).add (x.mult yl)).add (xr.mult yl).neg) XR.attach YL.attach
  Game.mk L R
  termination_by x y => x.birthday + y.birthday
  decreasing_by
  -- =================================================
  -- First zipwith
  -- =================================================
  -- 1. xl * y
  · have hxl_lt : xl.birthday < (mk XL XR).birthday :=
      -- Updated variable usage: hxl -> _hxl
      birthday_lt_left (mk XL XR) xl (by simpa [Game.left] using _hxl)
    have hmeasure : xl.birthday + y.birthday < (mk XL XR).birthday + y.birthday :=
      add_lt_add_right hxl_lt y.birthday
    simpa [hy] using hmeasure

  -- 2. x * yl
  · have hyl_lt : yl.birthday < (mk YL YR).birthday :=
      -- Updated variable usage: hyl -> _hyl
      birthday_lt_left (mk YL YR) yl (by simpa [Game.left] using _hyl)
    have hmeasure : x.birthday + yl.birthday < x.birthday + (mk YL YR).birthday :=
      add_lt_add_left hyl_lt x.birthday
    simpa [hx] using hmeasure

  -- 3. xl * yl
  · have hxl_lt : xl.birthday < (mk XL XR).birthday :=
      birthday_lt_left (mk XL XR) xl (by simpa [Game.left] using _hxl)
    have hyl_lt : yl.birthday < (mk YL YR).birthday :=
      birthday_lt_left (mk YL YR) yl (by simpa [Game.left] using _hyl)
    have hmeasure : xl.birthday + yl.birthday < (mk XL XR).birthday + (mk YL YR).birthday :=
      add_lt_add hxl_lt hyl_lt
    -- Change 2: Fixed indentation for assumption
    assumption

  -- =================================================
  -- Second zipwith
  -- =================================================

  -- 4. xr * y
  · have hxr_lt : xr.birthday < (mk XL XR).birthday :=
      birthday_lt_right (mk XL XR) xr (by simpa [Game.right] using _hxr)
    have hmeasure : xr.birthday + y.birthday < (mk XL XR).birthday + y.birthday :=
      add_lt_add_right hxr_lt y.birthday
    simpa [hy] using hmeasure

  -- 5. x * yr
  · have hyr_lt : yr.birthday < (mk YL YR).birthday :=
      birthday_lt_right (mk YL YR) yr (by simpa [Game.right] using _hyr)
    have hmeasure : x.birthday + yr.birthday < x.birthday + (mk YL YR).birthday :=
      add_lt_add_left hyr_lt x.birthday
    simpa [hx] using hmeasure

  -- 6. xr * yr
  · have hxr_lt : xr.birthday < (mk XL XR).birthday :=
      birthday_lt_right (mk XL XR) xr (by simpa [Game.right] using _hxr)
    have hyr_lt : yr.birthday < (mk YL YR).birthday :=
      birthday_lt_right (mk YL YR) yr (by simpa [Game.right] using _hyr)
    have hmeasure : xr.birthday + yr.birthday < (mk XL XR).birthday + (mk YL YR).birthday :=
      add_lt_add hxr_lt hyr_lt
    assumption

  -- =================================================
  -- Third zipwith
  -- =================================================

  -- 7. xl * y
  · have hxl_lt : xl.birthday < (mk XL XR).birthday :=
      birthday_lt_left (mk XL XR) xl (by simpa [Game.left] using _hxl)
    have hmeasure : xl.birthday + y.birthday < (mk XL XR).birthday + y.birthday :=
      add_lt_add_right hxl_lt y.birthday
    simpa [hy] using hmeasure

  -- 8. x * yr
  · have hyr_lt : yr.birthday < (mk YL YR).birthday :=
      birthday_lt_right (mk YL YR) yr (by simpa [Game.right] using _hyr)
    have hmeasure : x.birthday + yr.birthday < x.birthday + (mk YL YR).birthday :=
      add_lt_add_left hyr_lt x.birthday
    simpa [hx] using hmeasure

  -- 9. xl * yr
  · have hxl_lt : xl.birthday < (mk XL XR).birthday :=
      birthday_lt_left (mk XL XR) xl (by simpa [Game.left] using _hxl)
    have hyr_lt : yr.birthday < (mk YL YR).birthday :=
      birthday_lt_right (mk YL YR) yr (by simpa [Game.right] using _hyr)
    have hmeasure : xl.birthday + yr.birthday < (mk XL XR).birthday + (mk YL YR).birthday :=
      add_lt_add hxl_lt hyr_lt
    assumption

  -- =================================================
  -- Fourth Zipwith
  -- =================================================

  -- 10. xr * y
  · have hxr_lt : xr.birthday < (mk XL XR).birthday :=
      birthday_lt_right (mk XL XR) xr (by simpa [Game.right] using _hxr)
    have hmeasure : xr.birthday + y.birthday < (mk XL XR).birthday + y.birthday :=
      add_lt_add_right hxr_lt y.birthday
    simpa [hy] using hmeasure

  -- 11. x * yl
  · have hyl_lt : yl.birthday < (mk YL YR).birthday :=
      birthday_lt_left (mk YL YR) yl (by simpa [Game.left] using _hyl)
    have hmeasure : x.birthday + yl.birthday < x.birthday + (mk YL YR).birthday :=
      add_lt_add_left hyl_lt x.birthday
    simpa [hx] using hmeasure

  -- 12. xr * yl
  · have hxr_lt : xr.birthday < (mk XL XR).birthday :=
      birthday_lt_right (mk XL XR) xr (by simpa [Game.right] using _hxr)
    have hyl_lt : yl.birthday < (mk YL YR).birthday :=
      birthday_lt_left (mk YL YR) yl (by simpa [Game.left] using _hyl)
    have hmeasure : xr.birthday + yl.birthday < (mk XL XR).birthday + (mk YL YR).birthday :=
      add_lt_add hxr_lt hyl_lt
    assumption
